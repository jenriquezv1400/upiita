#include "esp_hosted_transport_config.h"

// wifiType.h
#define WiFiMode_t  wifi_mode_t
#define WIFI_OFF    WIFI_MODE_NULL
#define WIFI_STA    WIFI_MODE_STA

/*
 * WiFi INIT
 * */

static bool lowLevelInitDone = false;

static bool hosted_initialized = false;

static bool wifiHostedInit() {
  if (!hosted_initialized) {
    hosted_initialized = true;
    struct esp_hosted_sdio_config conf = INIT_DEFAULT_HOST_SDIO_CONFIG();
    conf.pin_clk.pin = CONFIG_ESP_SDIO_PIN_CLK;
    conf.pin_cmd.pin = CONFIG_ESP_SDIO_PIN_CMD;
    conf.pin_d0.pin = CONFIG_ESP_SDIO_PIN_D0;
    conf.pin_d1.pin = CONFIG_ESP_SDIO_PIN_D1;
    conf.pin_d2.pin = CONFIG_ESP_SDIO_PIN_D2;
    conf.pin_d3.pin = CONFIG_ESP_SDIO_PIN_D3;
    //conf.pin_rst.pin = CONFIG_ESP_SDIO_GPIO_RESET_SLAVE;
    // esp_hosted_sdio_set_config() will fail on second attempt but here temporarily to not cause exception on reinit
    if (esp_hosted_sdio_set_config(&conf) != ESP_OK || esp_hosted_init() != ESP_OK) {
      log_e("esp_hosted_init failed!");
      hosted_initialized = false;
      return false;
    }
    log_v("ESP-HOSTED initialized!");
  }
  // Attach pins to PeriMan here
  // Slave chip model is CONFIG_IDF_SLAVE_TARGET
  // CONFIG_ESP_SDIO_PIN_CMD
  // CONFIG_ESP_SDIO_PIN_CLK
  // CONFIG_ESP_SDIO_PIN_D0
  // CONFIG_ESP_SDIO_PIN_D1
  // CONFIG_ESP_SDIO_PIN_D2
  // CONFIG_ESP_SDIO_PIN_D3
  // CONFIG_ESP_SDIO_GPIO_RESET_SLAVE

  /*
  CONFIG_ESP_SDIO_PIN_CMD=19
CONFIG_ESP_SDIO_PIN_CLK=18
CONFIG_ESP_SDIO_PIN_D0=14
CONFIG_ESP_SDIO_PIN_D1=15
CONFIG_ESP_SDIO_PIN_D2=16
CONFIG_ESP_SDIO_PIN_D3=17
*/

  return true;
}

bool wifiLowLevelInit(bool persistent) {
  if (!lowLevelInitDone) {
    lowLevelInitDone = true;
#if CONFIG_ESP_WIFI_REMOTE_ENABLED
    if (!wifiHostedInit()) {
      lowLevelInitDone = false;
      return lowLevelInitDone;
    }
#endif
    if (!Network.begin()) {
      lowLevelInitDone = false;
      return lowLevelInitDone;
    }

    wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT();

    if (!WiFiGenericClass::useStaticBuffers()) {
      cfg.static_tx_buf_num = 0;
      cfg.dynamic_tx_buf_num = 32;
      cfg.tx_buf_type = 1;
      cfg.cache_tx_buf_num = 4;  // can't be zero!
      cfg.static_rx_buf_num = 4;
      cfg.dynamic_rx_buf_num = 32;
    }

    esp_err_t err = esp_wifi_init(&cfg);
    if (err) {
      log_e("esp_wifi_init 0x%x: %s", err, esp_err_to_name(err));
      lowLevelInitDone = false;
      return lowLevelInitDone;
    }
// Temporary fix to ensure that CDC+JTAG stay on on ESP32-C3
#if CONFIG_IDF_TARGET_ESP32C3
    phy_bbpll_en_usb(true);
#endif
    if (!persistent) {
      lowLevelInitDone = esp_wifi_set_storage(WIFI_STORAGE_RAM) == ESP_OK;
    }
    if (lowLevelInitDone) {
      initWiFiEvents();
      if (esp_netifs[ESP_IF_WIFI_AP] == NULL) {
        esp_netifs[ESP_IF_WIFI_AP] = esp_netif_create_default_wifi_ap();
      }
      if (esp_netifs[ESP_IF_WIFI_STA] == NULL) {
        esp_netifs[ESP_IF_WIFI_STA] = esp_netif_create_default_wifi_sta();
      }

      arduino_event_t arduino_event;
      arduino_event.event_id = ARDUINO_EVENT_WIFI_READY;
      Network.postEvent(&arduino_event);
    }
  }
  return lowLevelInitDone;
}

static bool _esp_wifi_started = false;

static bool espWiFiStart() {
  if (_esp_wifi_started) {
    return true;
  }
  _esp_wifi_started = true;
  esp_err_t err = esp_wifi_start();
  if (err != ESP_OK) {
    _esp_wifi_started = false;
    log_e("esp_wifi_start 0x%x: %s", err, esp_err_to_name(err));
    return _esp_wifi_started;
  }
  return _esp_wifi_started;
}

// -----------------------------------------------------------------------------------------------------------------------
// ------------------------------------------------- Generic WiFi function -----------------------------------------------
// -----------------------------------------------------------------------------------------------------------------------

bool WiFiGenericClass::_persistent = true;

/**
 * set new mode
 * @param m WiFiMode_t
 */

 // #define WiFiMode_t  wifi_mode_t
bool WiFiGenericClass::mode(wifi_mode_t m) {
  wifi_mode_t cm = getMode();
  if (cm == m) {
    return true;
  }
  if (!cm && m) {
    // Turn ON WiFi
    if (!wifiLowLevelInit(_persistent)) {
      return false;
    }
    Network.onSysEvent(_eventCallback);
  }

  if (((m & WIFI_MODE_STA) != 0) && ((cm & WIFI_MODE_STA) == 0)) {
    // we are enabling STA interface
    WiFi.STA.onEnable();
  }
  if (((m & WIFI_MODE_AP) != 0) && ((cm & WIFI_MODE_AP) == 0)) {
    // we are enabling AP interface
    WiFi.AP.onEnable();
  }

  if (cm && !m) {
    // Turn OFF WiFi
    if (!espWiFiStop()) {
      return false;
    }
    if ((cm & WIFI_MODE_STA) != 0) {
      // we are disabling STA interface
      WiFi.STA.onDisable();
    }
    if ((cm & WIFI_MODE_AP) != 0) {
      // we are disabling AP interface
      WiFi.AP.onDisable();
    }
    Network.removeEvent(_eventCallback);
    return true;
  }

  esp_err_t err;
  if (((m & WIFI_MODE_STA) != 0) && ((cm & WIFI_MODE_STA) == 0)) {
    err = esp_netif_set_hostname(esp_netifs[ESP_IF_WIFI_STA], NetworkManager::getHostname());
    if (err) {
      log_e("Could not set hostname! 0x%x: %s", err, esp_err_to_name(err));
      return false;
    }
  }
  err = esp_wifi_set_mode(m);
  if (err) {
    log_e("Could not set mode! 0x%x: %s", err, esp_err_to_name(err));
    return false;
  }

  if (((m & WIFI_MODE_STA) == 0) && ((cm & WIFI_MODE_STA) != 0)) {
    // we are disabling STA interface (but AP is ON)
    WiFi.STA.onDisable();
  }
  if (((m & WIFI_MODE_AP) == 0) && ((cm & WIFI_MODE_AP) != 0)) {
    // we are disabling AP interface (but STA is ON)
    WiFi.AP.onDisable();
  }

  if (_long_range) {
    if (m & WIFI_MODE_STA) {
      err = esp_wifi_set_protocol(WIFI_IF_STA, WIFI_PROTOCOL_LR);
      if (err != ESP_OK) {
        log_e("Could not enable long range on STA! 0x%x: %s", err, esp_err_to_name(err));
        return false;
      }
    }
    if (m & WIFI_MODE_AP) {
      err = esp_wifi_set_protocol(WIFI_IF_AP, WIFI_PROTOCOL_LR);
      if (err != ESP_OK) {
        log_e("Could not enable long range on AP! 0x%x: %s", err, esp_err_to_name(err));
        return false;
      }
    }
  } else {
#if CONFIG_SOC_WIFI_HE_SUPPORT
#define WIFI_PROTOCOL_DEFAULT (WIFI_PROTOCOL_11B | WIFI_PROTOCOL_11G | WIFI_PROTOCOL_11N | WIFI_PROTOCOL_11AX)
#else
#define WIFI_PROTOCOL_DEFAULT (WIFI_PROTOCOL_11B | WIFI_PROTOCOL_11G | WIFI_PROTOCOL_11N)
#endif
    uint8_t current_protocol = 0;
    if (m & WIFI_MODE_STA) {
      err = esp_wifi_get_protocol(WIFI_IF_STA, &current_protocol);
      if (err == ESP_OK && current_protocol == WIFI_PROTOCOL_LR) {
        log_v("Disabling long range on STA");
        err = esp_wifi_set_protocol(WIFI_IF_STA, WIFI_PROTOCOL_DEFAULT);
        if (err != ESP_OK) {
          log_e("Could not disable long range on STA! 0x%x: %s", err, esp_err_to_name(err));
        }
      }
    }
    if (m & WIFI_MODE_AP) {
      err = esp_wifi_get_protocol(WIFI_IF_AP, &current_protocol);
      if (err == ESP_OK && current_protocol == WIFI_PROTOCOL_LR) {
        log_v("Disabling long range on AP");
        err = esp_wifi_set_protocol(WIFI_IF_AP, WIFI_PROTOCOL_DEFAULT);
        if (err != ESP_OK) {
          log_e("Could not disable long range on AP! 0x%x: %s", err, esp_err_to_name(err));
        }
      }
    }
  }
  // === espWiFiStart ====
  if (!espWiFiStart()) {
    return false;
  }

#ifdef BOARD_HAS_DUAL_ANTENNA
  if (!setDualAntennaConfig(ANT1, ANT2, WIFI_RX_ANT_AUTO, WIFI_TX_ANT_AUTO)) {
    log_e("Dual Antenna Config failed!");
    return false;
  }
#endif

  return true;
}

/**
 * get WiFi mode
 * @return WiFiMode
 */
wifi_mode_t WiFiGenericClass::getMode() {
  if (!lowLevelInitDone || !_esp_wifi_started) {
    return WIFI_MODE_NULL;
  }
  wifi_mode_t mode;
  if (esp_wifi_get_mode(&mode) != ESP_OK) {
    log_w("WiFi not started");
    return WIFI_MODE_NULL;
  }
  return mode;
}

/** esp_wifi.h
  * @brief  Get current operating mode of WiFi
  *
  * @param[out]  mode  store current WiFi mode
  *
  * @return
  *    - ESP_OK: succeed
  *    - ESP_ERR_WIFI_NOT_INIT: WiFi is not initialized by esp_wifi_init
  *    - ESP_ERR_INVALID_ARG: invalid argument
  */
esp_err_t esp_wifi_get_mode(wifi_mode_t *mode); // esp_wifi_get_mode

/**. esp_wifi.h
  * @brief  Initialize WiFi
  *         Allocate resource for WiFi driver, such as WiFi control structure, RX/TX buffer,
  *         WiFi NVS structure etc. This WiFi also starts WiFi task
  *
  * @attention 1. This API must be called before all other WiFi API can be called
  * @attention 2. Always use WIFI_INIT_CONFIG_DEFAULT macro to initialize the configuration to default values, this can
  *               guarantee all the fields get correct value when more fields are added into wifi_init_config_t
  *               in future release. If you want to set your own initial values, overwrite the default values
  *               which are set by WIFI_INIT_CONFIG_DEFAULT. Please be notified that the field 'magic' of
  *               wifi_init_config_t should always be WIFI_INIT_CONFIG_MAGIC!
  *
  * @param  config pointer to WiFi initialized configuration structure; can point to a temporary variable.
  *
  * @return
  *    - ESP_OK: succeed
  *    - ESP_ERR_NO_MEM: out of memory
  *    - others: refer to error code esp_err.h
  */
esp_err_t esp_wifi_init(const wifi_init_config_t *config);

// esp_err.h
#define ESP_OK          0       /*!< esp_err_t value indicating success (no error) */

// esp_wifi.h -> esp_wifi_types.h -> esp_wifi_types_generic.h
/**
  * @brief Wi-Fi mode type
  */
typedef enum {
    WIFI_MODE_NULL = 0,  /**< Null mode */
    WIFI_MODE_STA,       /**< Wi-Fi station mode */
    WIFI_MODE_AP,        /**< Wi-Fi soft-AP mode */
    WIFI_MODE_APSTA,     /**< Wi-Fi station + soft-AP mode */
    WIFI_MODE_NAN,       /**< Wi-Fi NAN mode */
    WIFI_MODE_MAX
} wifi_mode_t;